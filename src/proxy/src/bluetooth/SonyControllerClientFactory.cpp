/**
 * @file SonyControllerClientFactory.cpp
 */

/**********************************************************************

  Created: 25 juil. 2021

    Copyright (C) 2021 jerome@jeromelaheurte.net

**********************************************************************/

#include <fcntl.h>
#include <unistd.h>
#include <glib-unix.h>

#include <bluetooth/bluetooth.h>
#include <bluetooth/l2cap.h>

#include "BTUtils.h"
#include "SonyControllerClientFactory.h"

static const uint8_t sdp_pdu_response[] = {
  0x07, 0x00, 0x01, 0x01, 0x5b, 0x01, 0x58, 0x36, 0x01, 0x55, 0x36, 0x00,
  0x32, 0x09, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x05, 0x09, 0x00, 0x01,
  0x35, 0x03, 0x19, 0x11, 0x0a, 0x09, 0x00, 0x04, 0x35, 0x10, 0x35, 0x06,
  0x19, 0x01, 0x00, 0x09, 0x00, 0x19, 0x35, 0x06, 0x19, 0x00, 0x19, 0x09,
  0x01, 0x03, 0x09, 0x00, 0x09, 0x35, 0x08, 0x35, 0x06, 0x19, 0x11, 0x0d,
  0x09, 0x01, 0x03, 0x36, 0x00, 0x32, 0x09, 0x00, 0x00, 0x0a, 0x00, 0x01,
  0x00, 0x06, 0x09, 0x00, 0x01, 0x35, 0x03, 0x19, 0x11, 0x0b, 0x09, 0x00,
  0x04, 0x35, 0x10, 0x35, 0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x19, 0x35,
  0x06, 0x19, 0x00, 0x19, 0x09, 0x01, 0x03, 0x09, 0x00, 0x09, 0x35, 0x08,
  0x35, 0x06, 0x19, 0x11, 0x0d, 0x09, 0x01, 0x03, 0x36, 0x00, 0x3b, 0x09,
  0x00, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x07, 0x09, 0x00, 0x01, 0x35, 0x06,
  0x19, 0x11, 0x0e, 0x19, 0x11, 0x0f, 0x09, 0x00, 0x04, 0x35, 0x10, 0x35,
  0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x17, 0x35, 0x06, 0x19, 0x00, 0x17,
  0x09, 0x01, 0x04, 0x09, 0x00, 0x09, 0x35, 0x08, 0x35, 0x06, 0x19, 0x11,
  0x0e, 0x09, 0x01, 0x05, 0x09, 0x03, 0x11, 0x09, 0x00, 0x03, 0x36, 0x00,
  0x4d, 0x09, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x08, 0x09, 0x00, 0x01,
  0x35, 0x03, 0x19, 0x11, 0x0c, 0x09, 0x00, 0x04, 0x35, 0x10, 0x35, 0x06,
  0x19, 0x01, 0x00, 0x09, 0x00, 0x17, 0x35, 0x06, 0x19, 0x00, 0x17, 0x09,
  0x01, 0x04, 0x09, 0x00, 0x09, 0x35, 0x08, 0x35, 0x06, 0x19, 0x11, 0x0e,
  0x09, 0x01, 0x05, 0x09, 0x00, 0x0d, 0x35, 0x10, 0x35, 0x06, 0x19, 0x01,
  0x00, 0x09, 0x00, 0x1b, 0x35, 0x06, 0x19, 0x00, 0x17, 0x09, 0x01, 0x04,
  0x09, 0x03, 0x11, 0x09, 0x00, 0x01, 0x36, 0x00, 0x5a, 0x09, 0x00, 0x00,
  0x0a, 0x00, 0x01, 0x00, 0x0a, 0x09, 0x00, 0x01, 0x35, 0x03, 0x19, 0x12,
  0x00, 0x09, 0x00, 0x04, 0x35, 0x0d, 0x35, 0x06, 0x19, 0x01, 0x00, 0x09,
  0x00, 0x01, 0x35, 0x03, 0x19, 0x00, 0x01, 0x09, 0x00, 0x05, 0x35, 0x03,
  0x19, 0x10, 0x02, 0x09, 0x00, 0x09, 0x35, 0x08, 0x35, 0x06, 0x19, 0x12,
  0x00, 0x09, 0x01, 0x03, 0x09, 0x02, 0x00, 0x09, 0x01, 0x03, 0x09, 0x02,
  0x01, 0x09, 0x05, 0x4c, 0x09, 0x02, 0x02, 0x09, 0x08, 0x1f, 0x09, 0x02,
  0x03, 0x09, 0x04, 0x00, 0x09, 0x02, 0x04, 0x28, 0x01, 0x09, 0x02, 0x05,
  0x09, 0x00, 0x02, 0x00
};

namespace dsremap
{
  SonyControllerClientFactory::SonyControllerClientFactory(BluetoothAcceptor& acceptor, const std::string& addr, int fd)
    : BluetoothAcceptor::ClientFactory(),
      Application::Component(acceptor),
      Logger("SonyControllerClientFactory"),
      _acceptor(acceptor),
      _state(State::SDP),
      _addr(addr),
      _fd_0x01(fd),
      _fd_0x11(-1),
      _fd_0x13(-1)
  {
    g_unix_fd_add(fd, G_IO_IN, &SonyControllerClientFactory::static_io_callback, static_cast<gpointer>(this));
  }

  SonyControllerClientFactory::~SonyControllerClientFactory()
  {
    while (g_source_remove_by_user_data(static_cast<gpointer>(this)));
    ::close(_fd_0x01);

    if (_state != State::Done) {
      if (_fd_0x11 != -1)
        ::close(_fd_0x11);
      if (_fd_0x13 != -1)
        ::close(_fd_0x13);
    }
  }

  bool SonyControllerClientFactory::on_new_connection(BluetoothAcceptor& acceptor, const std::string& addr, uint16_t psm, uint16_t cid, int fd)
  {
    if (addr == _addr) {
      switch (psm) {
        case 0x01:
          if (_state == State::WaitingConnect) {
            // Hum.
            _acceptor.remove_client_factory(this);
            _state = State::SDP;
            _fd_0x01 = fd;
            g_unix_fd_add(fd, G_IO_IN, &SonyControllerClientFactory::static_io_callback, static_cast<gpointer>(this));
          }
          break;
        case 0x11:
          _fd_0x11 = fd;
          break;
        case 0x13:
          _fd_0x13 = fd;
          break;
        default:
          error("Unknown PSM 0x{:02x}", psm);
          acceptor.remove_client_factory(this);
          delete this;
          return true;
      }

      if ((_fd_0x11 != -1) && (_fd_0x13 != -1)) {
        acceptor.remove_client_factory(this);

        set_l2cap_socket_options(_fd_0x11);
        set_l2cap_socket_options(_fd_0x13);

        info("Moving to state Done");

        _state = State::Done;

        try {
          _acceptor.create_proxy(_fd_0x11, _fd_0x13);
        } catch (const std::exception& exc) {
          error("Error while creating proxy: {}", exc.what());
        }

        delete this;
      }

      return true;
    }

    return false;
  }

  void SonyControllerClientFactory::stop()
  {
    _acceptor.remove_client_factory(this);
    delete this;
  }

  void SonyControllerClientFactory::reconfigure()
  {
  }

  gboolean SonyControllerClientFactory::static_io_callback(gint fd, GIOCondition cond, gpointer ptr)
  {
    return static_cast<SonyControllerClientFactory*>(ptr)->io_callback(fd, cond);
  }

  bool SonyControllerClientFactory::io_callback(int fd, GIOCondition)
  {
    uint8_t data[1024];
    size_t len = ::read(fd, data, sizeof(data));
    if (len < 0) {
      error("Read error on SDP channel: {}", ::strerror(errno));
      ::close(fd);
      _fd_0x01 = -1;
      delete this;
      return false;
    }

    if (len == 0) {
      info("SDP channel closed; moving to state WaitingConnect");

      _state = State::WaitingConnect;
      _acceptor.add_client_factory(this);

      ::close(fd);
      _fd_0x01 = -1;
      return false;
    }

    debug("Received {} bytes on SDP channel", len);
    debug_hex(data, len);

    if ((len != 20) || (data[0] != 0x06)) {
      error("Unexpected data on SDP channel");
      ::close(fd);
      _fd_0x01 = -1;
      delete this;
      return false;
    }

    debug("Sending PDU response");
    int written = ::write(fd, sdp_pdu_response, sizeof(sdp_pdu_response));
    if (written < 0) {
      error("Write error on SDP channel: {}", ::strerror(errno));
      ::close(fd);
      _fd_0x01 = -1;
      delete this;
      return false;
    }

    debug("{} bytes sent", written);

    return true;
  }
}
